# Project Specification: itack CLI

## Overview

itack is a minimalist, Git-backed issue tracker designed for humans and AI agents. It manages issues as individual Markdown files with YAML front matter, stored directly within a repository. The goal is to provide a structured, CLI-driven way to coordinate work across multiple branches and agents without leaving the terminal.

## Core Technical Stack

- **Language:** Rust
- **CLI Framework:** clap (v4+)
- **Data Format:** Markdown files (.md) with YAML Front Matter
- **Local Storage:** `.itack/` directory in the repository root (git-tracked)
- **Global State:** `~/.itack/` directory for user config and cross-repo state

## 1. Storage Architecture

### Per-Repository Storage (`.itack/`)

Located at the repository root, tracked by git:

```
.itack/
├── metadata.toml  # Project identity (project_id)
├── 1.md
├── 2.md
└── 3.md
```

Each issue is a separate file to avoid merge conflicts when multiple agents/users update different issues simultaneously.

### `.itack/metadata.toml`

```toml
# Unique project identifier, generated on init
# Used to locate the project's state DB in ~/.itack/
project_id = "quick-cobra-15"
```

The `project_id` is a human-readable identifier generated using a format like [human-readable-ids](https://www.npmjs.com/package/human-readable-ids) (adjective-animal-number). This ensures:

- Multiple worktrees of the same repo share the same DB (same `project_id` in git)
- Different repos have isolated state (different `project_id`)

### Global Storage (`~/.itack/`)

User-level configuration and per-project state:

```
~/.itack/
├── config.toml              # User preferences (global)
└── quick-cobra-15/          # Project-specific directory
    └── state.db             # SQLite database for this project
```

## 2. Global Configuration

### `~/.itack/config.toml`

```toml
# Override $EDITOR for itack edit
editor = "nvim"

# Default output format (table | json)
output_format = "table"
```

All fields are optional. The tool should work with an empty or missing config file.

### `~/.itack/<project_id>/state.db` Schema

SQLite database for project-specific state (not tracked by git):

```sql
-- Schema version for rebuild detection
CREATE TABLE meta (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL
);
-- Initialized with: INSERT INTO meta (key, value) VALUES ('schema_version', '1');

-- Track next issue ID for this project
CREATE TABLE state (
    id INTEGER PRIMARY KEY CHECK (id = 1),  -- Singleton row
    next_issue_id INTEGER DEFAULT 1
);

-- Track active claims for locking
CREATE TABLE claims (
    issue_id INTEGER PRIMARY KEY,
    assignee TEXT NOT NULL,
    claimed_at TEXT NOT NULL        -- ISO 8601 timestamp
);
```

The schema is simple because each project has its own DB - no need to key by repository path.

#### Schema Version & Rebuild

On startup, the CLI:

1. Reads `project_id` from `.itack/metadata.toml`
2. Opens `~/.itack/<project_id>/state.db`
3. Checks `meta.schema_version`

If version is missing or outdated:

1. Acquire exclusive lock on the database
2. Re-check version (another process may have already rebuilt)
3. If still outdated, drop all tables and recreate schema
4. Rebuild state from markdown files (see below)
5. Release lock

**Rebuild logic** (scans current worktree's `.itack/` directory):

- `next_issue_id`: Find max ID from `*.md` filenames, set to max + 1
- `claims`: For each file with `assignee` set and `status: in-progress`, insert into claims table

SQLite state is always derivable from the markdown files. The DB is purely for local concurrency control; git handles cross-branch coordination via merge conflicts on the markdown files.

#### ID Generation

When creating a new issue:

1. Atomically increment and return the ID:
   ```sql
   UPDATE state
   SET next_issue_id = next_issue_id + 1
   WHERE id = 1
   RETURNING next_issue_id - 1;
   ```

This guarantees unique IDs even with concurrent `itack create` calls across multiple worktrees.

#### Claim Locking

When claiming an issue:

1. Begin SQLite transaction
2. Attempt `INSERT INTO claims (issue_id, assignee, claimed_at)`
3. If insert fails (row exists), abort and return error: "Issue already claimed by {assignee}"
4. If insert succeeds, update the markdown file
5. Commit transaction

When releasing an issue:

1. `DELETE FROM claims WHERE issue_id = ?`
2. Update the markdown file (set assignee to empty, status to open)

This ensures two agents cannot claim the same issue simultaneously, even across different worktrees of the same project.

## 3. Issue Data Schema

Each issue is a file: `.itack/<id>.md`

### YAML Front Matter Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `id` | integer | yes | Unique identifier, auto-generated |
| `title` | string | yes | Issue title |
| `status` | enum | yes | `open`, `in-progress`, `done` |
| `assignee` | string | no | e.g., `"claude-agent-1"` or `"cameron"` |
| `epic` | string | no | Used for grouping related issues |
| `created_at` | timestamp | yes | ISO 8601 format |

### Example File: `.itack/101.md`

```markdown
---
assignee: claude-code-alpha
created_at: 2026-01-25T10:00:00Z
epic: Authentication
id: 101
status: in-progress
title: Implement OAuth2 Flow
---

# Description

We need to add the Google OAuth2 provider to the login page...
```

Note: YAML keys are alphabetically sorted for diff-friendly output.

## 4. Functional Requirements

### R0: Initialization

| Command | Description |
|---------|-------------|
| `itack init` | Creates `.itack/` directory with `metadata.toml` (generates unique `project_id`). Creates `~/.itack/<project_id>/state.db`. Creates `~/.itack/config.toml` if it doesn't exist. |

### R1: Issue Management

| Command | Description |
|---------|-------------|
| `itack create "<title>" [--epic "<name>"]` | Generates a new `.md` file with a unique ID and default status `open` |
| `itack show <id> [--json]` | Prints the issue to stdout (useful for agents) |
| `itack edit <id>` | Opens the issue file in `$EDITOR` (or configured editor) |
| `itack status <id> <status>` | Updates the status field in the YAML |

### R2: Assignment & Coordination

| Command | Description |
|---------|-------------|
| `itack claim <id> <name>` | Sets assignee and moves status to `in-progress`. Name is required. |
| `itack release <id>` | Removes the assignee and moves status back to `open` |

### R3: Listing & Grouping

| Command | Description |
|---------|-------------|
| `itack list` | Displays a table of all issues |
| `itack list --epic "<name>"` | Filters by epic |
| `itack list --status <status>` | Filters by status |
| `itack list --assignee <name>` | Filters by assignee |
| `itack list --json` | Output as JSON array |

### R4: Project Overview

| Command | Description |
|---------|-------------|
| `itack board` | Summary showing issue counts by status and list of in-progress tasks with assignees |
| `itack board --json` | Output as JSON |

## 5. Implementation Details

### Initialization Behavior

On first run of any command (not just `init`):
- If `~/.itack/` doesn't exist, create it with empty `config.toml`
- If `~/.itack/<project_id>/` doesn't exist, create it with initialized `state.db`
- Commands other than `init` should fail gracefully if `.itack/` doesn't exist in the repo

### YAML Serialization

For diff-friendly output:
- Sort keys alphabetically
- Use consistent 2-space indentation
- No trailing whitespace
- Single newline at end of file

### Git Integration

- Verify the current directory is within a git repository
- Do not auto-commit changes (user/agent handles commits)
- Exit with error if not in a git repo

### Error Handling

| Condition | Behavior |
|-----------|----------|
| Not in a git repo | Error: "Not a git repository" |
| `.itack/` doesn't exist | Error: "Not initialized. Run `itack init` first." |
| Issue ID not found | Error: "Issue <id> not found" |
| Invalid status value | Error: "Invalid status. Must be: open, in-progress, done" |
| Claim conflict | Error: "Issue <id> already claimed by <assignee>" |
| Claim on done issue | Error: "Cannot claim issue <id>: status is done" |
| Release on unclaimed issue | No-op (success, no error) |

### Exit Codes

| Code | Meaning |
|------|---------|
| 0 | Success |
| 1 | General error (invalid args, file not found, etc.) |
| 2 | Conflict (claim failed because already claimed) |

### Output Formats

- **Table (default):** Human-readable columns, truncated to terminal width
- **JSON (`--json`):** Machine-readable, full content, one object per issue

### List Sorting

Default sort order for `itack list`:
1. Status priority: `in-progress` → `open` → `done`
2. Within same status: by `id` ascending

This puts actionable work at the top.

## 6. Why Rust?

Using Rust ensures the binary is portable and extremely fast. For an AI agent that might run `itack list` dozens of times an hour, sub-millisecond response time reduces both token costs and "thinking" latency.

### Recommended Crates

| Crate | Purpose |
|-------|---------|
| `clap` | CLI argument parsing |
| `serde` + `serde_yaml` | YAML front matter parsing |
| `toml` | Config and metadata file parsing |
| `chrono` | Timestamp handling (ISO 8601) |
| `rusqlite` | SQLite for project state |
| `dirs` | Cross-platform `~/.itack/` path resolution |
| `comfy-table` or `tabled` | Table output formatting |
| `names` or custom | Human-readable project ID generation (adjective-animal-number) |
